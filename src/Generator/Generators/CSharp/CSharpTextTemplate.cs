using System;
using System.Collections.Generic;
using System.Linq;
using Cxxi.Types;

namespace Cxxi.Generators.CSharp
{
    public class CSharpTextTemplate : TextTemplate
    {
        public ITypePrinter TypePrinter { get; set; }

        public CSharpTextTemplate(Driver driver, TranslationUnit unit)
            : base(driver, unit)
        {
            TypePrinter = new CSharpTypePrinter(driver.TypeDatabase, driver.Library);
        }

        // from https://github.com/mono/mono/blob/master/mcs/class/System/Microsoft.CSharp/CSharpCodeGenerator.cs
        private static string[] keywords = new string[]
            {
                "abstract", "event", "new", "struct", "as", "explicit", "null", "switch", "base", "extern",
                "this", "false", "operator", "throw", "break", "finally", "out", "true",
                "fixed", "override", "try", "case", "params", "typeof", "catch", "for",
                "private", "foreach", "protected", "checked", "goto", "public",
                "unchecked", "class", "if", "readonly", "unsafe", "const", "implicit", "ref",
                "continue", "in", "return", "using", "virtual", "default",
                "interface", "sealed", "volatile", "delegate", "internal", "do", "is",
                "sizeof", "while", "lock", "stackalloc", "else", "static", "enum",
                "namespace",
                "object", "bool", "byte", "float", "uint", "char", "ulong", "ushort",
                "decimal", "int", "sbyte", "short", "double", "long", "string", "void",
                "partial", "yield", "where"
            };

        public static string SafeIdentifier(string proposedName)
        {
            proposedName =
                new string(((IEnumerable<char>) proposedName).Select(c => char.IsLetterOrDigit(c) ? c : '_').ToArray());
            return keywords.Contains(proposedName) ? "@" + proposedName : proposedName;
        }

        public override string FileExtension
        {
            get { return "cs"; }
        }

        public override void Generate()
        {
            GenerateStart();

            WriteLine("using System;");
            WriteLine("using System.Runtime.InteropServices;");
            NewLine();

            WriteLine("namespace {0}", SafeIdentifier(Driver.Options.LibraryName));
            WriteStartBraceIndent();

            GenerateDeclarations();

            WriteCloseBraceIndent();
        }

        public void GenerateStart()
        {
            if (Transform != null)
            {
                Transform.GenerateStart(this);
                return;
            }

            WriteLine("//----------------------------------------------------------------------------");
            WriteLine("// This is autogenerated code by Cxxi.");
            WriteLine("// Do not edit this file or all your changes will be lost after re-generation.");
            WriteLine("//----------------------------------------------------------------------------");
        }

        public void GenerateDeclarations()
        {
            // Generate all the enum declarations for the module.
            foreach (var @enum in TranslationUnit.Enums)
            {
                if (@enum.Ignore || @enum.IsIncomplete)
                    continue;

                GenerateEnum(@enum);
                NewLine();
            }

            // Generate all the typedef declarations for the module.
            foreach (var typedef in TranslationUnit.Typedefs)
            {
                if (typedef.Ignore) continue;

                if (!GenerateTypedef(typedef))
                    continue;

                NewLine();
            }

            // Generate all the struct/class declarations for the module.
            foreach (var @class in TranslationUnit.Classes)
            {
                if (@class.Ignore) continue;

                GenerateClass(@class);
                NewLine();
            }

            if (TranslationUnit.HasFunctions)
            {
                WriteLine("public partial class " + SafeIdentifier(Options.LibraryName));
                WriteStartBraceIndent();

                // Generate all the function declarations for the module.
                foreach (var function in TranslationUnit.Functions)
                    GenerateFunction(function);

                WriteCloseBraceIndent();
            }
        }

        public void GenerateDeclarationCommon(Declaration T)
        {
            GenerateSummary(T.BriefComment);
            GenerateDebug(T);
        }

        #region Classes

        public void GenerateClass(Class @class)
        {
            if (@class.Ignore) return;
            GenerateDeclarationCommon(@class);

            GenerateClassProlog(@class);

            NewLine();
            WriteStartBraceIndent();

            if (!@class.IsOpaque)
                GenerateClassFields(@class);

            WriteCloseBraceIndent();
        }

        public void GenerateClassProlog(Class @class)
        {
            if (@class.IsUnion)
                WriteLine("[StructLayout(LayoutKind.Explicit)]");

            Write("public unsafe ");

            if (@class.IsAbstract)
                Write("abstract ");

            Write("class {0}", SafeIdentifier(@class.Name));

            if (@class.HasBase)
                Write(" : {0}", SafeIdentifier(@class.Bases[0].Class.Name));
        }

        public void GenerateClassFields(Class @class)
        {
            foreach (var field in @class.Fields)
            {
                if (field.Ignore) continue;

                GenerateDeclarationCommon(field);
                if (@class.IsUnion)
                    WriteLine("[FieldOffset({0})]", field.Offset);
                WriteLine("public {0} {1};", field.Type, SafeIdentifier(field.Name));
            }
        }

        #endregion

        public bool GenerateTypedef(TypedefDecl typedef)
        {
            if (typedef.Ignore)
                return false;

            GenerateDeclarationCommon(typedef);

            FunctionType func;
            TagType tag;

            if (typedef.Type.IsPointerToPrimitiveType(PrimitiveType.Void)
                || typedef.Type.IsPointerTo<TagType>(out tag))
            {
                WriteLine("public class " + SafeIdentifier(typedef.Name) + @" { }");
            }
            else if (typedef.Type.IsPointerTo<FunctionType>(out func))
            {
                //WriteLine("public {0};",
                //    string.Format(func.ToDelegateString(), SafeIdentifier(T.Name)));
            }
            else if (typedef.Type.IsEnumType())
            {
                // Already handled in the parser.
                return false;
            }
            else
            {
                Console.WriteLine("Unhandled typedef type: {0}", typedef);
                return false;
            }

            return true;
        }

        public void GenerateEnum(Enumeration @enum)
        {
            if (@enum.Ignore) return;
            GenerateDeclarationCommon(@enum);

            if (@enum.IsFlags)
                WriteLine("[Flags]");

            Write("public enum {0}", SafeIdentifier(@enum.Name));

            var typeName = TypePrinter.VisitPrimitiveType(@enum.BuiltinType.Type,
                                                          new TypeQualifiers());

            if (@enum.BuiltinType.Type != PrimitiveType.Int32)
                Write(" : {0}", typeName);

            NewLine();

            WriteStartBraceIndent();
            for (var i = 0; i < @enum.Items.Count; ++i)
            {
                var item = @enum.Items[i];
                GenerateInlineSummary(item.Comment);

                Write(item.ExplicitValue
                          ? string.Format("{0} = {1}", SafeIdentifier(item.Name), item.Value)
                          : string.Format("{0}", SafeIdentifier(item.Name)));

                if (i < @enum.Items.Count - 1)
                    Write(",");

                NewLine();
            }
            WriteCloseBraceIndent();
        }

        public void GenerateFunction(Function function)
        {
            if(function.Ignore) return;
            GenerateDeclarationCommon(function);

            Write("[DllImport(\"{0}.dll\", ", SafeIdentifier(Library.SharedLibrary));
            Write("CallingConvention = CallingConvention.{0}, ", ToCSharpCallConv(function.CallingConvention));
            WriteLine("EntryPoint=\"{0}\")]", function.Mangled);

            Write("public unsafe static extern {0} {1}(", function.ReturnType,
                      SafeIdentifier(function.Name));

            for(var i = 0; i < function.Parameters.Count; ++i)
            {
                var param = function.Parameters[i];
                Write("{0} {1}", param.Type, SafeIdentifier(param.Name));

                if (i < function.Parameters.Count - 1)
                    Write(", ");
            }

            WriteLine(");");
        }

        public static string ToCSharpCallConv(CallingConvention convention)
        {
            switch (convention)
            {
                case CallingConvention.Default:
                    return "Winapi";
                case CallingConvention.C:
                    return "Cdecl";
                case CallingConvention.StdCall:
                    return "StdCall";
                case CallingConvention.ThisCall:
                    return "ThisCall";
                case CallingConvention.FastCall:
                    return "FastCall";
            }

            return "Winapi";
        }

        public void GenerateDebug(Declaration decl)
        {
            if(Options.OutputDebug && !String.IsNullOrWhiteSpace(decl.DebugText))
                WriteLine("// DEBUG: " + decl.DebugText);
        }

        public void GenerateSummary(string comment)
        {
            if(String.IsNullOrWhiteSpace(comment))
                return;

            WriteLine("/// <summary>");
            WriteLine("/// {0}", comment);
            WriteLine("/// </summary>");
        }

        public void GenerateInlineSummary(string comment)
        {
            if(String.IsNullOrWhiteSpace(comment))
                return;

            WriteLine("/// <summary>{0}</summary>", comment);
        }
    }
}